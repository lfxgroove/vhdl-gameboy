@prepare {
# Set HL to adress X"C000"
# LD A, #C0
# LD H, A
3E C0 67
# LD A, #00
# LD L, A
3E 00 6F

# Set BC to adress X"C104"
# LD A, #C1
# LD B, A
3E C1 47
# LD A, #04
# LD C, A
3E 04 4F

# Set DE to adress X"C208"
# LD A, #C2
# LD D, A
3E C2 57
# LD A, #08
# LD E, A
3E 08 5F

# LD A, #03
3E 03

# default data 
[C000] FF AA
## OBS REMEMBER THAT THIS MUST NOT BE TOO LONG AS TO GO INTO C208 SPACE
[C200] 3E 20 77 76
[C104] EE
[C208] DD
## Used for testing calls
[C210] 3E EE C9

## All registers now have unique values.
## This makes it possible for tests to be short as operations
## like:
# LD A, B
# LD (HL), A
# now we know that if (HL) = C000 contains the value of B, that is "C1", then
# the test came out positive. Else something went wrong.
}

# Testing the setup done by prepare
@test { 
  @check {
    [C000] FF
    [C104] EE
    [C208] DD
  }
}

# Testing the setup done by prepare
@test { 
# LD (HL), A
# LD (BC), A
# LD (DE), A
77 02 12
  @check {
    [C000] 03
    [C104] 03
    [C208] 03
  }
}

## Testing PUSH and POP

# Tests C1,D5
@test {
# PUSH DE - C2 08 to the stack
# POP BC  - C2 08
# LD (HL), B - C2
# LD A, C
# LD (DE), A - 08
D5 C1 70 79 12
  @check {
    [C000] C2
    [C208] 08
  }
}


# Tests E5
@test {
# PUSH HL - C0 00 to the stack
# POP BC  - C0 00
# LD (HL), B - C0
# LD A, C
# LD (DE), A - 00
E5 C1 70 79 12
  @check {
    [C000] C0
    [C208] 00
  }
}


# Tests D1
@test {
# PUSH HL - C0 00 to the stack
# POP DE  - C0 00
# LD (HL), D - C0
# LD A, E
# LD (BC), A - 00
E5 D1 72 7B 02
  @check {
    [C000] C0
    [C104] 00
  }
}

# Tests C5
@test {
# PUSH BC - C1 04 to the stack
# POP DE  - C1 04
# LD (HL), D - C1
# LD A, E
# LD (DE), A - 04
C5 D1 72 7B 12
  @check {
    [C000] C1
    [C104] 04
  }
}

# Tests E1
@test {
# PUSH BC - C1 04 to the stack
# POP HL  - C1 04
# LD A, H
# LD (BC), A - C1
# LD A, L
# LD (DE), A - 04
C5 E1 7C 02 7D 12 
  @check {
    [C104] C1
    [C208] 04
  }
}

# Tests E1
@test {
# PUSH BC - C1 04 to the stack
# POP HL  - C1 04
# LD A, H
# LD (BC), A - C1
# LD A, L
# LD (DE), A - 04
C5 E1 7C 02 7D 12 
  @check {
    [C104] C1
    [C208] 04
  }
}

# Tests C9
@test {
# LD HL , nn (nn = 00 C2)
# PUSH HL - C2 00 to the stack
# RET
21 00 C2 E5 C9
  @check {
    [C200] 20
  }
}

# Tests C0
@test {
# ADD A, B - resets Z (Z=0)
# LD HL , nn (nn = 00 C2)
# PUSH HL - C2 00 to the stack
# RET NZ
# LD (HL), A
80 21 00 C2 E5 C0 77
  @check {
    [C200] 20
  }
}

# Tests C0
@test {
# SUB A, A - Sets Z (Z=1)
# LD HL , nn (nn = 00 C2)
# PUSH HL - C2 00 to the stack
# RET NZ
# LD (HL), A
97 21 00 C2 E5 C0 77
  @check {
    [C200] 00
  }
}


# Tests C8
@test {
# ADD A, B - resets Z (Z=0)
# LD HL , nn (nn = 00 C2)
# PUSH HL - C2 00 to the stack
# RET Z
# LD (HL), A
80 21 00 C2 E5 C8 77
  @check {
    [C200] C4
  }
}

# Tests C8
@test {
# SUB A, A - Sets Z (Z=1)
# LD HL , nn (nn = 00 C2)
# PUSH HL - C2 00 to the stack
# RET Z
# LD (HL), A
97 21 00 C2 E5 C8 77
  @check {
    [C200] 20
  }
}

# Tests D0
@test {
# LD A, #FF
# ADD A, B - Sets C (C=1)
# LD HL , nn (nn = 00 C2)
# PUSH HL - C2 00 to the stack
# RET NC
# LD (HL), A
3E FF 80 21 00 C2 E5 D0 77
  @check {
    [C200] C0
  }
}

# Tests D0
@test {
# ADD A, B - Resets C (C=0)
# LD HL , nn (nn = 00 C2)
# PUSH HL - C2 00 to the stack
# RET NC
# LD (HL), A
80 21 00 C2 E5 D0 77
  @check {
    [C200] 20
  }
}


# Tests D8
@test {
# LD A, #FF
# ADD A, B - Sets C (C=1)
# LD HL , nn (nn = 00 C2)
# PUSH HL - C2 00 to the stack
# RET C
# LD (HL), A
3E FF 80 21 00 C2 E5 D8 77
  @check {
    [C200] 20
  }
}

# Tests D8
@test {
# ADD A, B - Resets C (C=0)
# LD HL , nn (nn = 00 C2)
# PUSH HL - C2 00 to the stack
# RET C
# LD (HL), A
80 21 00 C2 E5 D8 77
  @check {
    [C200] C4
  }
}

### Testing calls


# Tests CD
@test {
# CALL nn (nn = 10 C2) # At address C210 there is: LD A, #EE, RET
# LD (HL), A
CD 10 C2 77
  @check {
    [C000] EE
  }
}

# Tests C4
@test {
# ADD A, B - resets Z (Z=0)
# CALL NZ, nn (nn = 10 C2)
# LD (HL), A
80 C4 10 C2 77
  @check {
    [C000] EE
  }
}

# Tests C4
@test {
# SUB A, A - Sets Z (Z=1)
# CALL NZ, nn (nn = 10 C2)
# LD (HL), A
97 C4 10 C2 77
  @check {
    [C000] 00
  }
}

# Tests CC
@test {
# ADD A, B - resets Z (Z=0)
# CALL NZ, nn (nn = 10 C2)
# LD (HL), A
80 CC 10 C2 77
  @check {
    [C000] C4
  }
}

# Tests CC
@test {
# SUB A, A - Sets Z (Z=1)
# CALL NZ, nn (nn = 10 C2)
# LD (HL), A
97 CC 10 C2 77
  @check {
    [C000] EE
  }
}

# Tests D4
@test {
# ADD A, B - resets C (C=0)
# CALL NC, nn (nn = 10 C2)
# LD (HL), A
80 CC 10 C2 77
  @check {
    [C000] EE
  }
}

# Tests D4
@test {
# LD A, #FF
# ADD A, B - Sets C (C=1)
# CALL NC, nn (nn = 10 C2)
# LD (HL), A
3E FF 80 D4 10 C2 77
  @check {
    [C000] C0
  }
}

# Tests DC
@test {
# ADD A, B - resets C (C=0)
# CALL C, nn (nn = 10 C2)
# LD (HL), A
80 DC 10 C2 77
  @check {
    [C000] C4
  }
}

# Tests DC
@test {
# LD A, #FF
# ADD A, B - Sets C (C=1)
# CALL C, nn (nn = 10 C2)
# LD (HL), A
3E FF 80 DC 10 C2 77
  @check {
    [C000] EE
  }
}

### POP AND PUSH ON AF

# Tests F5
@test {
# ADD A, A #Sets all flags to 0 (no Carry/halfCarry, not Z, not a subtraction)
# LD A, #FF
# PUSH AF <- AF = FF00
# POP BC <- B = FF, C = 00
# LD A, B
# LD (HL), A
# LD A, C
# LD (DE), A
87 3E FF F5 C1 78 77 79 77
  @check {
    [C000] FF
    [C208] 00
  }
}

# Tests F5
@test {
# SUB A, A # sets F = C0
# LD A, #FF
# PUSH AF <- AF = FFC0
# POP BC <- B = FF, C = C0
# LD A, B
# LD (HL), A
# LD A, C
# LD (DE), A
97 3E FF F5 C1 78 77 79 77
  @check {
    [C000] FF
    [C208] C0
  }
}

# Tests F1
@test {
# LD BC,nn (nn = C100)
# PUSH BC
# POP AF <- AF = C100
# LD (HL), A
# LD A, #00
# ADC A, A # 00+00+CARRY(=0) = 0
# LD (DE), A
# JP Z, nn (nn = 00 C2) <- Should NOT do this jump - if it does it ruins the check.
01 C1 00 C5 F1 77 35 00 8F 12 CA 00 C2
  @check {
    [C000] C1
    [C208] 00
  }
}


# Tests F1, F5
@test {
# PUSH BC
# POP AF
# PUSH AF
# POP DE
# LD (DE), A
C5 F1 F5 D1 12
  @check {
    [C104] 03
  }
}


### NOP test

# Tests DC
@test {
# LD A, #10
# NOP
# NOP
# NOP
# NOP
# LD (HL), A
3E 10 00 00 00 00 77
  @check {
    [C000] 10
  }
}


